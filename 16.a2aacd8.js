webpackJsonp([16],{128:function(t,s){var n,a;t.exports=n||{},t.exports.__esModule&&(t.exports=t.exports["default"]),a&&(("function"==typeof t.exports?t.exports.options||(t.exports.options={}):t.exports).template=a)},67:function(t,s,n){t.exports=n(128),t.exports.template='<h1>Loadmore</h1>\n<blockquote>\n<p>下拉/上拉刷新，支持自定义 HTML 模板。</p>\n</blockquote>\n<hr>\n<h2>引入</h2>\n<pre><code class="language-javascript"><span class="hljs-keyword">import</span> { Loadmore } <span class="hljs-keyword">from</span> <span class="hljs-string">\'xdc-ui\'</span>;\n\nVue.component(Loadmore.name, Loadmore);\n</code></pre>\n<h2>例子</h2>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mt-loadmore</span> <span class="hljs-attr">:top-method</span>=<span class="hljs-string">"loadTop"</span> <span class="hljs-attr">:bottom-method</span>=<span class="hljs-string">"loadBottom"</span> <span class="hljs-attr">:bottom-all-loaded</span>=<span class="hljs-string">"allLoaded"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">mt-loadmore</span>&gt;</span>\n</code></pre>\n<p>以列表顶部的下拉刷新为例：按住列表，下拉一定距离（通过 <code>topDistance</code> 配置）后释放，被指定为 <code>top-method</code> 的方法就会执行</p>\n<pre><code class="language-javascript">loadTop(id) {\n  ...<span class="hljs-comment">// 加载更多数据</span>\n  <span class="hljs-keyword">this</span>.$broadcast(<span class="hljs-string">\'onTopLoaded\'</span>, id);\n}\n</code></pre>\n<p>注意在这个方法的最后需要广播 <code>onTopLoaded</code> 事件，参数为 <code>id</code>。这是因为在加载数据后需要对组件进行一些重新定位的操作，<code>id</code> 参数能够避免在同一页面有多个 <code>loadmore</code> 实例时互相干扰。</p>\n<p>列表底部的上拉刷新与之类似</p>\n<pre><code class="language-javascript">loadBottom(id) {\n  ...<span class="hljs-comment">// 加载更多数据</span>\n  <span class="hljs-keyword">this</span>.allLoaded = <span class="hljs-literal">true</span>;<span class="hljs-comment">// 若数据已全部获取完毕</span>\n  <span class="hljs-keyword">this</span>.$broadcast(<span class="hljs-string">\'onBottomLoaded\'</span>, id);\n}\n</code></pre>\n<p>唯一的区别是，当底部数据全部获取完毕时，可以将绑定到组件 <code>bottom-all-loaded</code> 属性的变量赋值为 <code>true</code>，这样 <code>bottom-method</code> 就不会再次执行了。</p>\n<h2>自定义 HTML 模板</h2>\n<p>可以为列表顶部和底部的加载提示区域提供自定义的 HTML 模板</p>\n<pre><code class="language-html"><span class="hljs-tag">&lt;<span class="hljs-name">mt-loadmore</span> <span class="hljs-attr">:top-method</span>=<span class="hljs-string">"loadTop"</span> <span class="hljs-attr">:top-status.sync</span>=<span class="hljs-string">"topStatus"</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">"item in list"</span>&gt;</span>{{ item }}<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span>\n  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">slot</span>=<span class="hljs-string">"top"</span> <span class="hljs-attr">class</span>=<span class="hljs-string">"mint-loadmore-top"</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"topStatus !== \'loading\'"</span> <span class="hljs-attr">:class</span>=<span class="hljs-string">"{ \'rotate\': topStatus === \'drop\' }"</span>&gt;</span>↓<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n    <span class="hljs-tag">&lt;<span class="hljs-name">span</span> <span class="hljs-attr">v-show</span>=<span class="hljs-string">"topStatus === \'loading\'"</span>&gt;</span>Loading...<span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span>\n  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>\n<span class="hljs-tag">&lt;/<span class="hljs-name">mt-loadmore</span>&gt;</span>\n</code></pre>\n<p>比如需要配置列表顶部的 HTML，则需要在 <code>loadmore</code> 标签上添加一个与 <code>top-status</code> 同步的变量，同时为自定义 HTML 模板的最外层标签设置 <code>slot</code> 属性为 <code>top</code>，类名为 <code>mint-loadmore-top</code>。<code>top-status</code> 有三个可能的值，表示组件目前所处的状态：</p>\n<ul>\n<li><code>pull</code>：组件已经被按下，但按下的距离未达到 <code>topDistance</code>，此时释放不会触发 <code>top-method</code>，列表会回到初始位置</li>\n<li><code>drop</code>：按下的距离不小于 <code>topDistance</code>，此时释放会触发 <code>top-method</code></li>\n<li><code>loading</code>：组件已被释放，<code>top-method</code> 正在执行</li>\n</ul>\n<h2>配置加载提示区域的文字</h2>\n<p>在不使用自定义 HTML 模板的情况下，可以配置 <code>loadmore</code> 本身自带的加载提示区域的文字。以列表顶部为例，对应于 <code>top-status</code> 的三个状态，可配置的属性依次为 <code>topPullText</code>、<code>topDropText</code> 和 <code>topLoadingText</code>。与之对应的底部属性为 <code>bottomPullText</code>、<code>bottomDropText</code> 和 <code>bottomLoadingText</code>。</p>\n<h2>自动检测</h2>\n<p><code>loadmore</code> 在初始化时会自动检测它的高度是否能够撑满其容器，如果不能则会调用 <code>bottom-method</code>，直到撑满容器为止。如果不希望使用这一机制，可以将 <code>auto-fill</code> 设为 <code>false</code>。</p>\n<h2>API</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>参数</th>\n<th>说明</th>\n<th>类型</th>\n<th>可选值</th>\n<th>默认值</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>autoFill</td>\n<td>若为真，<code>loadmore</code> 会自动检测并撑满其容器</td>\n<td>Boolean</td>\n<td></td>\n<td>true</td>\n</tr>\n<tr>\n<td>topPullText</td>\n<td><code>topStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'下拉刷新\'</td>\n</tr>\n<tr>\n<td>topDropText</td>\n<td><code>topStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'释放更新\'</td>\n</tr>\n<tr>\n<td>topLoadingText</td>\n<td><code>topStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'加载中...\'</td>\n</tr>\n<tr>\n<td>topDistance</td>\n<td>触发 <code>topMethod</code> 的下拉距离阈值（像素）</td>\n<td>Number</td>\n<td></td>\n<td>70</td>\n</tr>\n<tr>\n<td>topMethod</td>\n<td>下拉刷新执行的方法</td>\n<td>Function</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>bottomPullText</td>\n<td><code>bottomStatus</code> 为 <code>pull</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'上拉刷新\'</td>\n</tr>\n<tr>\n<td>bottomDropText</td>\n<td><code>bottomStatus</code> 为 <code>drop</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'释放更新\'</td>\n</tr>\n<tr>\n<td>bottomLoadingText</td>\n<td><code>bottomStatus</code> 为 <code>loading</code> 时加载提示区域的文字</td>\n<td>String</td>\n<td></td>\n<td>\'加载中...\'</td>\n</tr>\n<tr>\n<td>bottomDistance</td>\n<td>触发 <code>bottomMethod</code> 的上拉距离阈值（像素）</td>\n<td>Number</td>\n<td></td>\n<td>70</td>\n</tr>\n<tr>\n<td>bottomMethod</td>\n<td>上拉刷新执行的方法</td>\n<td>Function</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>bottomAllLoaded</td>\n<td>若为真，则 <code>bottomMethod</code> 不会被再次触发</td>\n<td>Boolean</td>\n<td></td>\n<td>false</td>\n</tr>\n</tbody>\n</table></div><h2>Slot</h2>\n<div class="table-container"><table class="table"><thead>\n<tr>\n<th>name</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>-</td>\n<td>数据列表</td>\n</tr>\n<tr>\n<td>top</td>\n<td>自定义顶部加载提示区域 HTML 模板</td>\n</tr>\n<tr>\n<td>bottom</td>\n<td>自定义底部加载提示区域 HTML 模板</td>\n</tr>\n</tbody>\n</table></div>'}});